extern crate futures;
use futures::executor::block_on;
use std::future::Future;

// async函数
async fn foo() -> u8 {
    5
}

fn bar() -> impl std::future::Future<Output = u8> {
    //async 块
    async {
        let x: u8 = foo().await;
        x + 5
    }
}

fn baz() -> impl std::future::Future<Output = u8> {
    let x = 5;
    // async move块
    let closure = async move { bar().await + x };

    closure
}

async fn hello_world() {
    println!("hello, world!");
}

use futures::channel::mpsc::{self, Receiver, Sender};
use futures::executor::{self, ThreadPool, ThreadPoolBuilder};
use futures::future::FutureExt;
use futures::stream::{FusedStream, Stream, StreamExt};
use futures::task::Poll;
use std::marker::PhantomPinned;
use std::pin::Pin;
use std::{thread, time};

struct Yield {
    rem: i32,
}

impl futures::future::Future for Yield {
    type Output = ();
    fn poll(mut self: Pin<&mut Self>, ctx: &mut std::task::Context<'_>) -> Poll<Self::Output> {
        let handle = thread::current();
        if self.rem == 0 {
            let name = handle.name();
            println!("{:?} ready", name);
            Poll::Ready(())
        } else {
            let name = handle.name();
            println!("{:?} self.rem:{}", name, self.rem);
            self.rem -= 1;
            ctx.waker().wake_by_ref();

            Poll::Pending
        }
    }
}

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }

    fn init<'a>(self: Pin<&'a mut Self>) {
        let self_ref: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ref;
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a String {
        assert!(
            !self.b.is_null(),
            "Test::b called without Test::init being called first"
        );
        unsafe { &*(self.b) }
    }
}
/// Why Pinning
/// file:///C:/repositories/rust/async-book/book/html/04_pinning/01_chapter.html
#[test]
fn why_pin() {
    // let mut test1 = Test::new("test1");
    // test1.init();
    // let mut test2 = Test::new("test2");
    // test2.init();

    // println!("a: {}, b: {}", test1.a(), test1.b());
    // std::mem::swap(&mut test1, &mut test2);
    // test1.a = "I've totally changed now!".to_string();
    // println!("a: {}, b: {}", test2.a(), test2.b());

    // test1 is safe to move before we initialize it
    let mut test1 = Test::new("test1");
    // Notice how we shadow `test1` to prevent it from being accessed again
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!(
        "a: {}, b: {}",
        Test::a(test1.as_ref()),
        Test::b(test1.as_ref())
    );
    // std::mem::swap(test1.get_mut(), test2.get_mut());
    println!(
        "a: {}, b: {}",
        Test::a(test2.as_ref()),
        Test::b(test2.as_ref())
    );
}

/// Pinning to the Heap
#[test]
fn unpin() {
    use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

    // A function which takes a `Future` that implements `Unpin`.
    fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */
    }

    // let fut = async { /* ... */ };
    // execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

    // Pinning with `Box`:
    let fut = async { /* ... */ };
    let fut = Box::pin(fut);
    execute_unpin_future(fut); // OK

    // Pinning with `pin_mut!`:
    let fut = async { /* ... */ };
    pin_mut!(fut);
    execute_unpin_future(fut); // OK
}

#[test]
fn demo() {
    let future = hello_world();

    let res1 = block_on(future);
    println!("---{:?}", res1);

    let pool = ThreadPool::new().unwrap();
    let (tx, rx) = mpsc::unbounded::<i32>();

    // Create a future by an async block, where async is responsible for an
    // implementation of Future. At this point no executor has been provided
    // to this future, so it will not be running.
    let fut_values = async {
        // Create another async block, again where the Future implementation
        // is generated by async. Since this is inside of a parent async block,
        // it will be provided with the executor of the parent block when the parent
        // block is executed.
        //
        // This executor chaining is done by Future::poll whose second argument
        // is a std::task::Context. This represents our executor, and the Future
        // implemented by this async block can be polled using the parent async
        // block's executor.
        let fut_tx_result = async move {
            (0..100).for_each(|v| {
                tx.unbounded_send(v).expect("Failed to send");
            })
        };

        // Use the provided thread pool to spawn the generated future
        // responsible for transmission
        pool.spawn_ok(fut_tx_result);

        let fut_values = rx.map(|v| v * 2).collect();

        // Use the executor provided to this async block to wait for the
        // future to complete.
        fut_values.await
    };

    // Actually execute the above future, which will invoke Future::poll and
    // subsequenty chain appropriate Future::poll and methods needing executors
    // to drive all futures. Eventually fut_values will be driven to completion.
    let values: Vec<i32> = executor::block_on(fut_values);

    println!("Values={:?}", values);

    let mut builder = ThreadPoolBuilder::new();
    builder.name_prefix("pool-");
    builder.pool_size(5);
    let pool = builder.create().unwrap();
    use super::*;
    for _ in 0..5 {
        let y = Yield { rem: 10 };
        // 使用主线程来执行任务
        // block_on(y);
        // 使用线程池来执行任务
        pool.spawn_ok(y);
    }

    let demo = baz();
    let result = block_on(demo);
    println!("baz result:{}", result);

    // 主线程等待子线程完成后关闭
    let ten_millis = time::Duration::from_millis(10);
    thread::sleep(ten_millis);
}

#[test]
fn stream_multiple_futures() {
    use futures::select;
    use futures::SinkExt;
    use pin_utils::pin_mut;

    async fn send_recv() {
        const BUFFER_SIZE: usize = 10;
        let (mut tx, mut rx) = mpsc::channel::<i32>(BUFFER_SIZE);

        tx.send(1).await.unwrap();
        tx.send(2).await.unwrap();
        drop(tx);

        // `StreamExt::next` is similar to `Iterator::next`, but returns a
        // type that implements `Future<Output = Option<T>>`.
        assert_eq!(Some(1), rx.next().await);
        assert_eq!(Some(2), rx.next().await);
        assert_eq!(None, rx.next().await);
        println!("send_recv done");
    }
    let future = send_recv();
    block_on(future);

    async fn task_one() { /* ... */
    }
    async fn task_two() { /* ... */
    }

    async fn race_tasks() {
        let t1 = task_one().fuse();
        let t2 = task_two().fuse();

        pin_mut!(t1, t2);

        //the futures used in select must implement both the Unpin trait and the FusedFuture trait.
        select! {
            () = t1 => println!("task one completed first"),
            () = t2 => println!("task two completed first"),
        }
    }
    let tasks = race_tasks();
    block_on(tasks);

    async fn count() {
        let mut a_fut = futures::future::ready(4);
        let mut b_fut = futures::future::ready(6);
        let mut total = 0;

        loop {
            select! {
                a = a_fut => total += a,
                b = b_fut => total += b,
                complete => break,
                default => unreachable!(), // never runs (futures are ready, then complete)
            };
        }
        assert_eq!(total, 10);
        println!("total:{}", total);
    }

    let cnt = count();
    block_on(cnt);
}
