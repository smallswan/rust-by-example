extern crate futures;
use futures::executor::block_on;
use std::future::Future;

async fn foo() -> u8 {
    5
}

fn bar() -> impl std::future::Future<Output = u8> {
    async {
        let x: u8 = foo().await;
        x + 5
    }
}

// fn baz() -> impl std::future::Future<Output = u8>{
// let closure = async move |x : u8| {
//     bar().await + x
// };
//
// closure(5)
// }

async fn hello_world() {
    println!("hello, world!");
}

use futures::channel::mpsc::{self, Receiver, Sender};
use futures::executor::{self, ThreadPool};
use futures::future::FutureExt;
use futures::stream::{FusedStream, Stream, StreamExt};

#[test]
fn demo() {
    let future = hello_world();

    let res1 = block_on(future);
    println!("---{:?}", res1);

    let pool = ThreadPool::new().unwrap();
    let (tx, rx) = mpsc::unbounded::<i32>();

    // Create a future by an async block, where async is responsible for an
    // implementation of Future. At this point no executor has been provided
    // to this future, so it will not be running.
    let fut_values = async {
        // Create another async block, again where the Future implementation
        // is generated by async. Since this is inside of a parent async block,
        // it will be provided with the executor of the parent block when the parent
        // block is executed.
        //
        // This executor chaining is done by Future::poll whose second argument
        // is a std::task::Context. This represents our executor, and the Future
        // implemented by this async block can be polled using the parent async
        // block's executor.
        let fut_tx_result = async move {
            (0..100).for_each(|v| {
                tx.unbounded_send(v).expect("Failed to send");
            })
        };

        // Use the provided thread pool to spawn the generated future
        // responsible for transmission
        pool.spawn_ok(fut_tx_result);

        let fut_values = rx.map(|v| v * 2).collect();

        // Use the executor provided to this async block to wait for the
        // future to complete.
        fut_values.await
    };

    // Actually execute the above future, which will invoke Future::poll and
    // subsequenty chain appropriate Future::poll and methods needing executors
    // to drive all futures. Eventually fut_values will be driven to completion.
    let values: Vec<i32> = executor::block_on(fut_values);

    println!("Values={:?}", values);
}
